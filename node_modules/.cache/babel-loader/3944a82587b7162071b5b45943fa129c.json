{"ast":null,"code":"import memorizedQuestions from \"./memorizedQuestions.json\";\n\nfunction preventStutter(word) {\n  //pra evitar que os proximos resultados nao saim embaralhados\n  return \" \" + word + \" \";\n}\n\nfunction sameWords(userInput) {\n  //jsonificar isso aquiiiii\n  // girias ou variacoes \n  let sameWords_in = [\"vc\", \"tu\", \"q\", \"o q\", \"oq\", \"5\", \"estacao\", \"de trem\", \"de metro\", \"fracos\", \"fortes\", \"por que\", \"pq\", \"programacao\", \"situacao\", \"fala\", \"conta\", \"realizacoes\", \"realizacao\", \"conquistas\", \"localizacao\"];\n  let sameWords_out = [\"voce\", \"voce\", \"que\", \"o que\", \"o que\", \"cinco\", \"estaçao\", \"\", \"\", \"fraco\", \"forte\", \"porque\", \"porque\", \"programaçao\", \"situaçao\", \"fale\", \"conte\", \"realizaçoes\", \"realizaçao\", \"conquista\", \"localizaçao\"];\n\n  for (let i = 0; i < sameWords_in.length; i++) {\n    userInput = preventStutter(userInput).replace(preventStutter(sameWords_in[i]), preventStutter(sameWords_out[i]));\n  } //converte palavras com significados iguais aos memorizados\n\n\n  return userInput; //entrega com as palavras com significados iguais convertidas para palavra padrao\n}\n\nfunction chewInput(string) {\n  //mastiga input deixando mais facil de entender\n  let result;\n  let mapaAcentosHex = {\n    a: /[\\xE0-\\xE6]/g,\n    e: /[\\xE8-\\xEB]/g,\n    i: /[\\xEC-\\xEF]/g,\n    o: /[\\xF2-\\xF6]/g,\n    u: /[\\xF9-\\xFC]/g,\n    c: /\\xE7/g,\n    n: /\\xF1/g\n  };\n\n  for (let letra in mapaAcentosHex) {\n    //retira acentos\n    let expressaoRegular = mapaAcentosHex[letra];\n    string = string.replace(expressaoRegular, letra);\n  }\n\n  let split = string.split(\" \");\n\n  for (let i = 0; i < split.length; i++) {\n    if (split[i] !== \"\") {\n      if (i === 0) {\n        result = split[i];\n      } else {\n        result = result + \" \" + split[i]; // depois add tipos de gagueira no stutter\n      }\n    }\n  }\n\n  return sameWords(result); // entrega com padrao aplicado em palavras com mesmo significado utilizadas\n}\n\nfunction splitCustom(string) {\n  //split sem posicoes vazias\n  let result = [];\n  string.split(\" \").forEach(element => {\n    if (element.length > 0) {\n      result.push(element);\n    }\n  });\n  return result;\n}\n\nfunction rememberQuestions(json) {\n  //retorna perguntas memorizadas\n  let result = [];\n  let keys = Object.keys(json);\n  keys.forEach(function (key) {\n    result.push(json[key]);\n  });\n  return result;\n}\n\nfunction buildStringWithCounter(str, numbers) {\n  //monta string com counter\n  if (numbers >= 0 || numbers <= 99) {\n    numbers = \"00\" + numbers;\n  } else if (numbers > 9 || numbers <= 99) {\n    numbers = \"0\" + numbers;\n  } else if (numbers > 99 || numbers <= 999) {\n    numbers = toString(numbers);\n  } else {\n    numbers = \"ERR\";\n  }\n\n  let result = str + numbers;\n  return result;\n}\n\nfunction searchByCounter(str) {\n  //procura se string prossui contador true false\n  let prefix = \"%%\";\n  let newString = str.substring(str.length - 5, str.length - 3);\n  let result = false;\n\n  if (newString === prefix) {\n    result = true;\n  }\n\n  return result;\n}\n\nfunction removeCounter(str) {\n  //remove contador da string para comparações - add validacao\n  return str.substring(0, str.length - 5);\n}\n\nfunction getCounter(str) {\n  //retorna contador inserido em string o\n  let result;\n\n  if (str.substring(str.length - 5, str.length - 3) === \"%%\") {\n    result = parseInt(str.substring(str.length - 3, str.length));\n  } else {\n    result = 1;\n  }\n\n  return;\n}\n\nfunction thinkingAboutKeys(recognizedKeys) {\n  // filtra chaves reconhecidas pelo maior contador informado pela AnalyzeKeys (independente de quantas keys forem)\n  let memoryCache = [];\n\n  for (let i = 0; i < recognizedKeys.length; i++) {\n    //filtra os contadores\n    if (i !== 0) {\n      if (getCounter(recognizedKeys[i]) >= getCounter(memoryCache[0])) {\n        memoryCache.unshift(recognizedKeys[i]);\n      } else {\n        memoryCache.push(recognizedKeys[i]);\n      }\n    } else {\n      memoryCache = [];\n      memoryCache.unshift(recognizedKeys[i]);\n    }\n  } //para proximas ideias no reconhecimento\n  //console.log(memoryCache)\n\n\n  let moreLikely = [memoryCache[0]]; // filtra cache com o maior(ou maiores iguais) contador(res)  -- add validacao\n\n  for (let i = 1; i < memoryCache.length; i++) {\n    if (getCounter(memoryCache[i]) === getCounter(moreLikely[0])) {\n      console.log(memoryCache[i]);\n      moreLikely.push(removeCounter(memoryCache[i]));\n    }\n  }\n\n  moreLikely[0] = removeCounter(moreLikely[0]);\n  return [moreLikely, memoryCache];\n}\n\nfunction analyzeQuestion(hmmIRemember, userInput) {\n  //dividido em parcial e final/ compara as palavras do input com as questoes memorizadas\n  let partialAnalysis = []; //analise parcial\n\n  hmmIRemember.forEach(itemRemembered => {\n    rememberQuestions(memorizedQuestions).forEach(obj => {\n      //carrega cada objetos do json\n      if (obj.id === itemRemembered) {\n        //compara cada palavra do input com da pergunta gravada na memoria\n        let memorizedQuestion = obj.questions;\n        let resultList = [];\n\n        for (let i = 0; i < memorizedQuestion.length; i++) {\n          //divide frases em palavras\n          let splitedMemQuestion = memorizedQuestion[i].split(\" \");\n          let splitedInputUser = chewInput(userInput).split(\" \");\n          let counterEqualWords = 0;\n\n          for (let ii = 0; ii < splitedMemQuestion.length; ii++) {\n            //compara as palavras\n            const wordInMem = splitedMemQuestion[ii];\n\n            for (let iii = 0; iii < splitedInputUser.length; iii++) {\n              const wordInInput = splitedInputUser[iii];\n\n              if (wordInInput === wordInMem) {\n                counterEqualWords++; // contadoooor\n              }\n            }\n          }\n\n          let percentualCompare = Math.floor(counterEqualWords * 100 / splitedMemQuestion.length);\n          resultList.push(percentualCompare);\n        }\n\n        let result = resultList[0]; //add validacao\n\n        for (let ii = 0; ii < resultList.length; ii++) {\n          //filtra o maior contador\n          if (resultList[ii] > result) {\n            result = resultList[ii];\n          }\n        }\n\n        partialAnalysis.push([obj.id, result]);\n      }\n    });\n  });\n  let finalAnalisys; // analise final\n\n  if (partialAnalysis.length > 1) {\n    //confere se apos analisar a questao, ainda existe um empate\n    finalAnalisys = [];\n    finalAnalisys.push(\"%%dontknow%%\");\n\n    for (let i = 0; i < partialAnalysis.length; i++) {\n      if (i === 0) {\n        finalAnalisys.push(partialAnalysis[i][0]);\n      } else if (i > 0 || partialAnalysis[i][1] === finalAnalisys[i - 1][0]) {\n        finalAnalisys.push(partialAnalysis[i][0]);\n      }\n    }\n  } else {\n    finalAnalisys = partialAnalysis[0][0];\n  }\n\n  return finalAnalisys;\n}\n\nfunction analyzeKeys(recognizingSomething) {\n  //analisa lista de keys reconhecidas\n  let thingsList = [];\n  let alreadyRecognized = false;\n\n  for (let i = 0; i < recognizingSomething.length; i++) {\n    //separa os itens reconhecidos\n    const itemRecognized = recognizingSomething[i];\n\n    for (let ii = 0; ii < thingsList.length; ii++) {\n      //separa os itens memorizados\n      const itemMemorized = thingsList[ii];\n\n      if (itemMemorized === itemRecognized) {\n        //compara\n        alreadyRecognized = true;\n      } else {\n        if (searchByCounter(itemMemorized)) {\n          if (removeCounter(itemMemorized) === itemRecognized) {\n            alreadyRecognized = true;\n          }\n        }\n      }\n    }\n\n    let prefixCounter = \"%%\";\n    let counter = 0;\n\n    if (alreadyRecognized) {\n      for (let ii = 0; ii < thingsList.length; ii++) {\n        let thing = thingsList[ii];\n\n        if (removeCounter(thing) === itemRecognized) {\n          counter++;\n          let numbers = parseInt(thing.substring(thing.length - 3, thing.length)) + 1;\n          thingsList[ii] = buildStringWithCounter(thingsList[ii].substring(0, thing.length - 3), numbers);\n        } else if (thing === itemRecognized) {\n          thingsList[ii] = buildStringWithCounter(thingsList[ii] + prefixCounter, counter);\n        }\n      }\n    } else {\n      counter++;\n      thingsList.push(buildStringWithCounter(itemRecognized + prefixCounter, counter));\n    }\n  }\n\n  console.log(thingsList);\n  return thingsList;\n}\n\nfunction getAnswersById(id) {\n  // retorna respostas do json pelo id da pergunta\n  let result;\n\n  if (Array.isArray(id)) {\n    // se nao souber responder - novo\n    result = [];\n\n    for (let i = 0; i < id.length; i++) {\n      const eachId = id[i];\n\n      for (let ii = 0; ii < memorizedQuestions.length; ii++) {\n        const memorizedId = memorizedQuestions[ii].id;\n\n        if (result[0] === undefined) {\n          result.push(\"Eu não entendi muito bem a sua pergunta\");\n          result.push(\"Você quis dizer alguns dos temas abaixo?\");\n        }\n\n        if (memorizedId === eachId) {\n          result.push(memorizedQuestions[ii].desc);\n        }\n      }\n    }\n  } else {\n    if (id === \"%%dontknow%%\") {\n      // se nao souber responder - antigo\n      result = [id];\n    } else {\n      //se souber\n      for (let i = 0; i < memorizedQuestions.length; i++) {\n        const memorizedId = memorizedQuestions[i].id;\n\n        if (memorizedId === id) {\n          result = memorizedQuestions[i].answers;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction compareWords(userInput, memorizedWord, memorizedQuestion) {\n  //compara palavras\n  let result = false;\n\n  if (userInput === memorizedWord) {\n    result = true;\n  }\n\n  return result;\n}\n\nconst questions = {\n  compare: userInput => {\n    let recognizingSomething = []; //mastiga a pergunta para entender mais facil && desmembra a pergunta para procurar pelos gatilhos de comparação(keys)\n\n    splitCustom(chewInput(userInput).toLowerCase()).forEach(wordInUserInput => {\n      rememberQuestions(memorizedQuestions).forEach(memorizedQuestion => {\n        let keys = memorizedQuestion.keys;\n        let passed1 = false; //bool condition\n\n        let passed2 = false; //bool condition\n\n        let twoFactoryValidation = false;\n\n        if (typeof keys === \"object\") {\n          //compara palavras vindas do usuarios com as keys\n          for (let i = 0; i < keys.length; i++) {\n            if (passed1) {\n              if (typeof keys[i] === \"object\") {\n                let checkKeys = keys[i];\n\n                for (let ii = 0; ii < checkKeys.length; ii++) {\n                  passed = compareWords(wordInUserInput, checkKeys[ii], memorizedQuestion);\n                }\n              } else {\n                passed = compareWords(wordInUserInput, keys[i], memorizedQuestion);\n              }\n            } else {\n              if (typeof keys[i] === \"object\") {\n                let checkKeys = keys[i];\n\n                for (let ii = 0; ii < checkKeys.length; ii++) {\n                  passed = compareWords(wordInUserInput, checkKeys[ii], memorizedQuestion);\n                }\n              } else {\n                passed = compareWords(wordInUserInput, keys[i], memorizedQuestion);\n              }\n            }\n          }\n        } else {\n          passed = compareWords(wordInUserInput, keys, memorizedQuestion); // revisar - entrada para comandos internos (futuro)\n        }\n\n        if (twoFactoryValidation) {\n          recognizingSomething.push(memorizedQuestion.id);\n        }\n      });\n    });\n    const myBrainIsArching = thinkingAboutKeys(analyzeKeys(recognizingSomething)); //analisa as keys identificadas e processa qual delas foi a mais acessada \n    //const keyCompareCache = myBrainIsArching[1]//para futuras atualizacoes\n\n    const hmmIRemember = myBrainIsArching[0]; //envia a resposta ja validada pelo analyze question\n    //console.log(getAnswersById(analyzeQuestion(hmmIRemember, userInput)))\n\n    return getAnswersById(analyzeQuestion(hmmIRemember, userInput));\n  }\n};\nexport default questions;","map":{"version":3,"sources":["C:/desenv/react-profile/profile/src/components/Chatbot/questions.js"],"names":["memorizedQuestions","preventStutter","word","sameWords","userInput","sameWords_in","sameWords_out","i","length","replace","chewInput","string","result","mapaAcentosHex","a","e","o","u","c","n","letra","expressaoRegular","split","splitCustom","forEach","element","push","rememberQuestions","json","keys","Object","key","buildStringWithCounter","str","numbers","toString","searchByCounter","prefix","newString","substring","removeCounter","getCounter","parseInt","thinkingAboutKeys","recognizedKeys","memoryCache","unshift","moreLikely","console","log","analyzeQuestion","hmmIRemember","partialAnalysis","itemRemembered","obj","id","memorizedQuestion","questions","resultList","splitedMemQuestion","splitedInputUser","counterEqualWords","ii","wordInMem","iii","wordInInput","percentualCompare","Math","floor","finalAnalisys","analyzeKeys","recognizingSomething","thingsList","alreadyRecognized","itemRecognized","itemMemorized","prefixCounter","counter","thing","getAnswersById","Array","isArray","eachId","memorizedId","undefined","desc","answers","compareWords","memorizedWord","compare","toLowerCase","wordInUserInput","passed1","passed2","twoFactoryValidation","checkKeys","passed","myBrainIsArching"],"mappings":"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","sourcesContent":["import memorizedQuestions from \"./memorizedQuestions.json\";\r\n\r\n\r\n\r\nfunction preventStutter(word) { //pra evitar que os proximos resultados nao saim embaralhados\r\n    return \" \" + word + \" \"\r\n}\r\n\r\nfunction sameWords(userInput) { //jsonificar isso aquiiiii\r\n    // girias ou variacoes \r\n    let sameWords_in = [\r\n        \"vc\",\r\n        \"tu\",\r\n        \"q\",\r\n        \"o q\",\r\n        \"oq\",\r\n        \"5\",\r\n        \"estacao\",\r\n        \"de trem\",\r\n        \"de metro\",\r\n        \"fracos\",\r\n        \"fortes\",\r\n        \"por que\",\r\n        \"pq\",\r\n        \"programacao\",\r\n        \"situacao\",\r\n        \"fala\",\r\n        \"conta\",\r\n        \"realizacoes\",\r\n        \"realizacao\",\r\n        \"conquistas\",\r\n        \"localizacao\"\r\n\r\n    ]\r\n    let sameWords_out = [\r\n        \"voce\",\r\n        \"voce\",\r\n        \"que\",\r\n        \"o que\",\r\n        \"o que\",\r\n        \"cinco\",\r\n        \"estaçao\",\r\n        \"\",\r\n        \"\",\r\n        \"fraco\",\r\n        \"forte\",\r\n        \"porque\",\r\n        \"porque\",\r\n        \"programaçao\",\r\n        \"situaçao\",\r\n        \"fale\",\r\n        \"conte\",\r\n        \"realizaçoes\",\r\n        \"realizaçao\",\r\n        \"conquista\",\r\n        \"localizaçao\"\r\n\r\n\r\n    ]\r\n    for (let i = 0; i < sameWords_in.length; i++) {\r\n        userInput = preventStutter(userInput).replace(preventStutter(sameWords_in[i]), preventStutter(sameWords_out[i]))\r\n    } //converte palavras com significados iguais aos memorizados\r\n\r\n    return userInput //entrega com as palavras com significados iguais convertidas para palavra padrao\r\n}\r\n\r\nfunction chewInput(string) { //mastiga input deixando mais facil de entender\r\n    let result\r\n    let mapaAcentosHex = {\r\n        a: /[\\xE0-\\xE6]/g,\r\n        e: /[\\xE8-\\xEB]/g,\r\n        i: /[\\xEC-\\xEF]/g,\r\n        o: /[\\xF2-\\xF6]/g,\r\n        u: /[\\xF9-\\xFC]/g,\r\n        c: /\\xE7/g,\r\n        n: /\\xF1/g\r\n    };\r\n    for (let letra in mapaAcentosHex) { //retira acentos\r\n        let expressaoRegular = mapaAcentosHex[letra]\r\n        string = string.replace(expressaoRegular, letra)\r\n    }\r\n    let split = string.split(\" \")\r\n    for (let i = 0; i < split.length; i++) {\r\n        if (split[i] !== \"\") {\r\n            if (i === 0) {\r\n                result = split[i]\r\n            } else {\r\n                result = result + \" \" + split[i] // depois add tipos de gagueira no stutter\r\n            }\r\n        }\r\n    }\r\n    return sameWords(result) // entrega com padrao aplicado em palavras com mesmo significado utilizadas\r\n}\r\n\r\nfunction splitCustom(string) { //split sem posicoes vazias\r\n    let result = []\r\n    string.split(\" \").forEach(element => {\r\n        if (element.length > 0) {\r\n            result.push(element)\r\n        }\r\n    })\r\n\r\n    return result\r\n}\r\n\r\nfunction rememberQuestions(json) { //retorna perguntas memorizadas\r\n    let result = [];\r\n    let keys = Object.keys(json);\r\n    keys.forEach(function (key) {\r\n        result.push(json[key]);\r\n    });\r\n\r\n    return result\r\n}\r\n\r\nfunction buildStringWithCounter(str, numbers) { //monta string com counter\r\n    if ((numbers >= 0) || (numbers <= 99)) {\r\n        numbers = \"00\" + numbers\r\n    } else if ((numbers > 9) || (numbers <= 99)) {\r\n        numbers = \"0\" + numbers\r\n    } else if ((numbers > 99) || (numbers <= 999)) {\r\n        numbers = toString(numbers)\r\n    } else {\r\n        numbers = \"ERR\"\r\n    }\r\n    let result = str + numbers\r\n    return result\r\n}\r\n\r\nfunction searchByCounter(str) { //procura se string prossui contador true false\r\n    let prefix = \"%%\"\r\n    let newString = str.substring(str.length - 5, str.length - 3)\r\n    let result = false\r\n    if (newString === prefix) {\r\n        result = true\r\n    }\r\n    return result\r\n}\r\n\r\nfunction removeCounter(str) { //remove contador da string para comparações - add validacao\r\n    return str.substring(0, str.length - 5)\r\n}\r\n\r\nfunction getCounter(str) { //retorna contador inserido em string o\r\n    let result\r\n\r\n    if (str.substring(str.length - 5, str.length - 3) === \"%%\") {\r\n        result = parseInt(str.substring(str.length - 3, str.length))\r\n    } else {\r\n        result = 1\r\n    }\r\n    return\r\n}\r\n\r\nfunction thinkingAboutKeys(recognizedKeys) { // filtra chaves reconhecidas pelo maior contador informado pela AnalyzeKeys (independente de quantas keys forem)\r\n    let memoryCache = []\r\n    for (let i = 0; i < recognizedKeys.length; i++) { //filtra os contadores\r\n        if (i !== 0) {\r\n            if (getCounter(recognizedKeys[i]) >= getCounter(memoryCache[0])) {\r\n                memoryCache.unshift(recognizedKeys[i])\r\n            } else {\r\n                memoryCache.push(recognizedKeys[i])\r\n            }\r\n        } else {\r\n            memoryCache = []\r\n            memoryCache.unshift(recognizedKeys[i])\r\n        }\r\n    } //para proximas ideias no reconhecimento\r\n    //console.log(memoryCache)\r\n\r\n    let moreLikely = [memoryCache[0]] // filtra cache com o maior(ou maiores iguais) contador(res)  -- add validacao\r\n    for (let i = 1; i < memoryCache.length; i++) {\r\n        if (getCounter(memoryCache[i]) === getCounter(moreLikely[0])) {\r\n            console.log(memoryCache[i])\r\n            moreLikely.push(removeCounter(memoryCache[i]))\r\n        }\r\n    }\r\n    moreLikely[0] = removeCounter(moreLikely[0])\r\n\r\n    return [moreLikely, memoryCache]\r\n}\r\n\r\nfunction analyzeQuestion(hmmIRemember, userInput) { //dividido em parcial e final/ compara as palavras do input com as questoes memorizadas\r\n    let partialAnalysis = [] //analise parcial\r\n\r\n    hmmIRemember.forEach(itemRemembered => {\r\n\r\n        rememberQuestions(memorizedQuestions).forEach(obj => { //carrega cada objetos do json\r\n\r\n            if (obj.id === itemRemembered) { //compara cada palavra do input com da pergunta gravada na memoria\r\n                let memorizedQuestion = obj.questions\r\n                let resultList = []\r\n                for (let i = 0; i < memorizedQuestion.length; i++) { //divide frases em palavras\r\n                    let splitedMemQuestion = memorizedQuestion[i].split(\" \")\r\n                    let splitedInputUser = chewInput(userInput).split(\" \")\r\n                    let counterEqualWords = 0\r\n\r\n                    for (let ii = 0; ii < splitedMemQuestion.length; ii++) { //compara as palavras\r\n                        const wordInMem = splitedMemQuestion[ii]\r\n                        for (let iii = 0; iii < splitedInputUser.length; iii++) {\r\n                            const wordInInput = splitedInputUser[iii]\r\n                            if (wordInInput === wordInMem) {\r\n                                counterEqualWords++ // contadoooor\r\n                            }\r\n                        }\r\n                    }\r\n                    let percentualCompare = Math.floor(counterEqualWords * 100 / splitedMemQuestion.length)\r\n                    resultList.push(percentualCompare)\r\n                }\r\n                let result = resultList[0] //add validacao\r\n\r\n\r\n                for (let ii = 0; ii < resultList.length; ii++) { //filtra o maior contador\r\n\r\n                    if (resultList[ii] > result) {\r\n                        result = resultList[ii]\r\n                    }\r\n                }\r\n                partialAnalysis.push([obj.id, result])\r\n            }\r\n        })\r\n    })\r\n\r\n    let finalAnalisys // analise final\r\n    if (partialAnalysis.length > 1) { //confere se apos analisar a questao, ainda existe um empate\r\n        finalAnalisys = []\r\n        finalAnalisys.push(\"%%dontknow%%\")\r\n\r\n\r\n        for (let i = 0; i < partialAnalysis.length; i++) {\r\n            if (i === 0) {\r\n                finalAnalisys.push(partialAnalysis[i][0])\r\n            } else if ((i > 0) || (partialAnalysis[i][1] === finalAnalisys[i - 1][0])) {\r\n                finalAnalisys.push(partialAnalysis[i][0])\r\n            }\r\n        }\r\n\r\n    } else {\r\n        finalAnalisys = partialAnalysis[0][0]\r\n    }\r\n\r\n    return finalAnalisys\r\n}\r\n\r\nfunction analyzeKeys(recognizingSomething) { //analisa lista de keys reconhecidas\r\n    let thingsList = []\r\n    let alreadyRecognized = false\r\n\r\n    for (let i = 0; i < recognizingSomething.length; i++) {//separa os itens reconhecidos\r\n        const itemRecognized = recognizingSomething[i]\r\n\r\n        for (let ii = 0; ii < thingsList.length; ii++) { //separa os itens memorizados\r\n            const itemMemorized = thingsList[ii]\r\n\r\n            if (itemMemorized === itemRecognized) { //compara\r\n                alreadyRecognized = true\r\n            } else {\r\n\r\n                if (searchByCounter(itemMemorized)) {\r\n\r\n                    if (removeCounter(itemMemorized) === itemRecognized) {\r\n                        alreadyRecognized = true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let prefixCounter = \"%%\"\r\n        let counter = 0\r\n        if (alreadyRecognized) {\r\n            for (let ii = 0; ii < thingsList.length; ii++) {\r\n                let thing = thingsList[ii]\r\n\r\n                if (removeCounter(thing) === itemRecognized) {\r\n                    counter++\r\n                    let numbers = parseInt(thing.substring(thing.length - 3, thing.length)) + 1\r\n                    thingsList[ii] = buildStringWithCounter(thingsList[ii].substring(0, thing.length - 3), numbers)\r\n\r\n                } else if (thing === itemRecognized) {\r\n                    thingsList[ii] = buildStringWithCounter(thingsList[ii] + prefixCounter, counter)\r\n\r\n                }\r\n            }\r\n        } else {\r\n            counter++\r\n            thingsList.push(buildStringWithCounter(itemRecognized + prefixCounter, counter))\r\n        }\r\n    }\r\n    console.log(thingsList)\r\n    return thingsList\r\n}\r\n\r\nfunction getAnswersById(id) { // retorna respostas do json pelo id da pergunta\r\n    let result\r\n\r\n    if (Array.isArray(id)) { // se nao souber responder - novo\r\n        result = []\r\n        for (let i = 0; i < id.length; i++) {\r\n            const eachId = id[i]\r\n\r\n            for (let ii = 0; ii < memorizedQuestions.length; ii++) {\r\n                const memorizedId = memorizedQuestions[ii].id\r\n\r\n                if (result[0] === undefined) {\r\n                    result.push(\"Eu não entendi muito bem a sua pergunta\")\r\n                    result.push(\"Você quis dizer alguns dos temas abaixo?\")\r\n                }\r\n                if (memorizedId === eachId) {\r\n                    result.push(memorizedQuestions[ii].desc)\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    } else {\r\n        if (id === \"%%dontknow%%\") { // se nao souber responder - antigo\r\n            result = [id]\r\n\r\n        } else { //se souber\r\n            for (let i = 0; i < memorizedQuestions.length; i++) {\r\n                const memorizedId = memorizedQuestions[i].id\r\n                if (memorizedId === id) {\r\n                    result = memorizedQuestions[i].answers\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return result\r\n}\r\n\r\nfunction compareWords(userInput, memorizedWord, memorizedQuestion) { //compara palavras\r\n    let result = false\r\n    if (userInput === memorizedWord) {\r\n        result = true\r\n    }\r\n    return result\r\n}\r\n\r\nconst questions = {\r\n    compare: (userInput) => {\r\n        let recognizingSomething = []\r\n\r\n\r\n\r\n        //mastiga a pergunta para entender mais facil && desmembra a pergunta para procurar pelos gatilhos de comparação(keys)\r\n        splitCustom(chewInput(userInput).toLowerCase()).forEach(wordInUserInput => {\r\n            rememberQuestions(memorizedQuestions).forEach(memorizedQuestion => {\r\n                let keys = memorizedQuestion.keys\r\n                let passed1 = false //bool condition\r\n                let passed2 = false //bool condition\r\n\r\n                let twoFactoryValidation = false\r\n                if (typeof (keys) === \"object\") { //compara palavras vindas do usuarios com as keys\r\n\r\n                    for (let i = 0; i < keys.length; i++) {\r\n                        if (passed1) {\r\n\r\n                            if (typeof (keys[i]) === \"object\") {\r\n                                let checkKeys = keys[i]\r\n                                for (let ii = 0; ii < checkKeys.length; ii++) {\r\n                                    passed = compareWords(wordInUserInput, checkKeys[ii], memorizedQuestion)\r\n                                }\r\n                            } else {\r\n                                passed = compareWords(wordInUserInput, keys[i], memorizedQuestion)\r\n                            }\r\n                        } else {\r\n                            if (typeof (keys[i]) === \"object\") {\r\n                                let checkKeys = keys[i]\r\n                                for (let ii = 0; ii < checkKeys.length; ii++) {\r\n                                    passed = compareWords(wordInUserInput, checkKeys[ii], memorizedQuestion)\r\n                                }\r\n                            } else {\r\n                                passed = compareWords(wordInUserInput, keys[i], memorizedQuestion)\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    passed = compareWords(wordInUserInput, keys, memorizedQuestion)\r\n                    // revisar - entrada para comandos internos (futuro)\r\n                }\r\n\r\n                if (twoFactoryValidation) {\r\n                    recognizingSomething.push(memorizedQuestion.id)\r\n                }\r\n            })\r\n        })\r\n        const myBrainIsArching = thinkingAboutKeys(analyzeKeys(recognizingSomething))//analisa as keys identificadas e processa qual delas foi a mais acessada \r\n        //const keyCompareCache = myBrainIsArching[1]//para futuras atualizacoes\r\n        const hmmIRemember = myBrainIsArching[0]\r\n\r\n        //envia a resposta ja validada pelo analyze question\r\n        //console.log(getAnswersById(analyzeQuestion(hmmIRemember, userInput)))\r\n        return getAnswersById(analyzeQuestion(hmmIRemember, userInput))\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\nexport default questions;"]},"metadata":{},"sourceType":"module"}