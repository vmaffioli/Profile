{"ast":null,"code":"import memory from \"./memory.json\";\nimport sameWords from \"./sameWords.json\";\n\nfunction preventStutter(word) {\n  //pra evitar que os proximos resultados nao saim embaralhados\n  return \" \" + word + \" \";\n}\n\nfunction padronizeWords(userInput) {\n  // girias ou variacoes \n  let sameWords_in = sameWords[0];\n  let sameWords_out = sameWords[1];\n\n  for (let i = 0; i < sameWords_in.length; i++) {\n    userInput = preventStutter(userInput).replace(preventStutter(sameWords_in[i]), preventStutter(sameWords_out[i]));\n  } //converte palavras com significados iguais aos memorizados\n\n\n  return userInput; //entrega com as palavras com significados iguais convertidas para palavra padrao\n}\n\nfunction rememberQuestions(json) {\n  //retorna perguntas memorizadas\n  let result = [];\n  let keys = Object.keys(json);\n  keys.forEach(function (key) {\n    result.push(json[key]);\n  });\n  return result;\n}\n\nfunction buildStringWithCounter(str, numbers) {\n  //monta string com counter\n  if (numbers >= 0 || numbers <= 99) {\n    numbers = \"00\" + numbers;\n  } else if (numbers > 9 || numbers <= 99) {\n    numbers = \"0\" + numbers;\n  } else if (numbers > 99 || numbers <= 999) {\n    numbers = toString(numbers);\n  } else {\n    numbers = \"ERR\";\n  }\n\n  let result = str + numbers;\n  return result;\n}\n\nfunction searchByCounter(str) {\n  //procura se string prossui contador true false\n  let prefix = \"%%\";\n  let newString = str.substring(str.length - 5, str.length - 3);\n  let result = false;\n\n  if (newString === prefix) {\n    result = true;\n  }\n\n  return result;\n}\n\nfunction removeCounter(str) {\n  //remove contador da string para comparações - add validacao\n  return str.substring(0, str.length - 5);\n}\n\nfunction getCounter(str) {\n  //add validacao\n  return parseInt(str.substring(str.length - 3, str.length));\n}\n\nfunction thinkingAboutKeys(array) {\n  // filtra chaves reconhecidas pelo maior contador informado pela AnalyzeKeys (independente de quantas keys forem)\n  let memoryCache; // para futuras implementacoes tb \n\n  let moreLikely;\n\n  if (array.length === 0) {\n    moreLikely = [\"%%dontknow%%\"];\n  } else {\n    for (let i = 0; i < array.length; i++) {\n      //filtra os contadores\n      if (memoryCache) {\n        if (getCounter(array[i]) >= getCounter(memoryCache[0])) {\n          memoryCache.unshift(array[i]);\n        } else {\n          memoryCache.push(array[i]);\n        }\n      } else {\n        memoryCache = [];\n        memoryCache.unshift(array[i]);\n      }\n    } //para proximas ideias no reconhecimento\n    //console.log(memoryCache)\n\n\n    moreLikely = [memoryCache[0]]; // filtra cache com o maior(ou maiores iguais) contador(res)  -- add validacao\n\n    for (let i = 1; i < memoryCache.length; i++) {\n      if (getCounter(memoryCache[i]) === getCounter(moreLikely[0])) {\n        moreLikely.push(removeCounter(memoryCache[i]));\n      }\n    }\n\n    moreLikely[0] = removeCounter(moreLikely[0]);\n  }\n\n  return [moreLikely, memoryCache];\n}\n\nfunction analyzeQuestion(hmmIRemember, userInput) {\n  //dividido em parcial e final/ compara as palavras do input com as questoes memorizadas\n  let partialAnalysis = []; //analise parcial\n\n  if (hmmIRemember[0] === \"%%dontknow%%\") {\n    // converte o nao reconhecido em nao lembrado rs\n    partialAnalysis.push(hmmIRemember);\n  }\n\n  hmmIRemember.forEach(itemRemembered => {\n    //verifica tudo q ele lembrou ao ler o que o usuario perguntou\n    rememberQuestions(memory).forEach(obj => {\n      //carrega cada objetos do json\n      if (obj.id === itemRemembered) {\n        //compara cada palavra do input com da pergunta gravada na memoria\n        let memorizedQuestion = obj.questions;\n        let resultList = [];\n\n        for (let i = 0; i < memorizedQuestion.length; i++) {\n          //divide frases em palavras\n          let splitedMemQuestion = memorizedQuestion[i].split(\" \");\n          let splitedInputUser = userInput.split(\" \");\n          let counterEqualWords = 0;\n\n          for (let ii = 0; ii < splitedMemQuestion.length; ii++) {\n            //compara as palavras\n            const wordInMem = splitedMemQuestion[ii];\n\n            for (let iii = 0; iii < splitedInputUser.length; iii++) {\n              const wordInInput = splitedInputUser[iii];\n\n              if (wordInInput === wordInMem) {\n                counterEqualWords++; // contadoooor\n              }\n            }\n          }\n\n          let percentualResult = Math.floor(counterEqualWords / splitedMemQuestion.length * 100);\n          resultList.push(percentualResult);\n        }\n\n        let result = resultList[0]; //add validacao\n\n        for (let ii = 0; ii < resultList.length; ii++) {\n          //filtra o maior contador\n          if (resultList[ii] > result) {\n            result = resultList[ii];\n          }\n        }\n\n        partialAnalysis.push([obj.id, result]);\n      }\n    });\n  });\n  console.log(partialAnalysis);\n  let finalAnalisys; // analise final\n\n  let cache = [];\n\n  if (partialAnalysis.length > 1) {\n    //confere se apos analisar a questao se ainda existe um empate\n    //finalAnalisys.push(\"%%draw%%\") //seta aqui o prefixo para responder empate\n    for (let i = 0; i < partialAnalysis.length; i++) {\n      if (i === 0) {\n        cache.push[partialAnalysis[i]];\n      } else {\n        if (partialAnalysis[i][1] > cache[0][1]) {\n          finalAnalisys = partialAnalysis[i][0];\n        } else if (partialAnalysis[i][1] === cache[0][1]) {\n          finalAnalisys.push;\n        }\n      }\n    }\n  } else {\n    finalAnalisys = partialAnalysis[0][0];\n  }\n\n  return finalAnalisys;\n}\n\nfunction analyzeKeys(recognizingSomething) {\n  //analisa lista de keys reconhecidas - para futuras implementações\n  let thingsList = [];\n  let alreadyRecognized = false;\n\n  for (let i = 0; i < recognizingSomething.length; i++) {\n    //separa os itens reconhecidos\n    const itemRecognized = recognizingSomething[i];\n\n    for (let ii = 0; ii < thingsList.length; ii++) {\n      //separa os itens memorizados\n      const itemMemorized = thingsList[ii];\n\n      if (itemMemorized === itemRecognized) {\n        //compara\n        alreadyRecognized = true;\n      } else {\n        if (searchByCounter(itemMemorized)) {\n          if (removeCounter(itemMemorized) === itemRecognized) {\n            alreadyRecognized = true;\n          }\n        }\n      }\n    }\n\n    let prefixCounter = \"%%\";\n    let counter = 0;\n\n    if (alreadyRecognized) {\n      for (let ii = 0; ii < thingsList.length; ii++) {\n        let thing = thingsList[ii];\n\n        if (removeCounter(thing) === itemRecognized) {\n          counter++;\n          let numbers = parseInt(thing.substring(thing.length - 3, thing.length)) + 1;\n          thingsList[ii] = buildStringWithCounter(thingsList[ii].substring(0, thing.length - 3), numbers);\n        } else if (thing === itemRecognized) {\n          thingsList[ii] = buildStringWithCounter(thingsList[ii] + prefixCounter, counter);\n        }\n      }\n    } else {\n      counter++;\n      thingsList.push(buildStringWithCounter(itemRecognized + prefixCounter, counter));\n    }\n  }\n\n  return thingsList;\n}\n\nfunction getAnswersById(id) {\n  // retorna respostas do json pelo id da pergunta\n  let result = [];\n\n  if (Array.isArray(id)) {\n    // em caso de empate ele recebe mais de 1 lista, entao ele processa a resposta para empate aqui\n    for (let i = 0; i < id.length; i++) {\n      const eachId = id[i];\n\n      for (let ii = 0; ii < memory.length; ii++) {\n        const memorizedId = memory[ii].id;\n\n        if (result[0] === undefined) {\n          result.push(\"Eu não entendi muito bem a sua pergunta\");\n          result.push(\"Você quis dizer alguns dos temas abaixo?\");\n        } else if (result[0] !== undefined && memorizedId === eachId) {\n          result.push(memory[ii].desc);\n        }\n\n        if (ii === memory) {\n          result.push(\"Caso seja algum desses, me diga qual\");\n          result.push(\"Se não for, tente refazer a pergunta usando outras palavras\");\n        }\n      }\n    }\n  } else if (id === \"%%dontknow%%\") {\n    // se nao reconhecer nenhuma chave, nada!\n    result.push(\"Essa pergunta eu não conheço =(\");\n    result.push(\"Vou anotar e pedir pro Vinícius original me ensinar a responder\");\n  } else {\n    //se souber e for somente 1 item,  caso limpo\n    for (let i = 0; i < memory.length; i++) {\n      const memorizedId = memory[i].id;\n\n      if (memorizedId === id) {\n        result = memory[i].answers;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction compareWords(userInput, memorizedWord) {\n  //compara palavras - so strings por enquanto\n  let result = false;\n\n  if (userInput.includes(memorizedWord)) {\n    result = true;\n  }\n\n  return result;\n}\n\nconst analyzeToAnswer = {\n  compare: userInput => {\n    let recognizingSomething = [];\n    userInput = padronizeWords(userInput); // aplica padrao para palavras com msm significado\n\n    rememberQuestions(memory).forEach(memorizedQuestion => {\n      //verifica se cada key existe no userInput\n      let keys = memorizedQuestion.keys;\n      let passedCounter = 0;\n      let twoFactory_1 = false; //validar as 2 keys\n\n      let twoFactory_2 = false;\n\n      if (typeof keys === \"object\") {\n        // precisa receber uma lista - é regra\n        for (let i = 0; i < keys.length; i++) {\n          //compara palavras vindas do usuarios com as keys\n          if (typeof keys[i] === \"object\") {\n            let checkKeys = keys[i];\n\n            for (let ii = 0; ii < checkKeys.length; ii++) {\n              if (passedCounter === 0 && compareWords(userInput, checkKeys[ii])) {\n                twoFactory_2 = true;\n              } else if (passedCounter === 1 && compareWords(userInput, checkKeys[ii])) {\n                twoFactory_1 = true;\n              } else if (passedCounter > 1) {\n                console.log(\"hey, estão me enviando chave a mais para analisar!! so pode 2 mininuuu\");\n              }\n            }\n          } else {\n            if (passedCounter === 0 && compareWords(userInput, keys[i])) {\n              twoFactory_2 = true;\n            } else if (passedCounter === 1 && compareWords(userInput, keys[i])) {\n              twoFactory_1 = true;\n            } else if (passedCounter > 1) {\n              //precisa vir uma lista de keys com 2 posicoes - a regra é clara!\n              console.log(\"Receiving an invalid keys list!\");\n            }\n          }\n\n          if (twoFactory_1 && twoFactory_2) {\n            recognizingSomething.push(memorizedQuestion.id);\n          }\n\n          passedCounter++;\n        }\n      } else {\n        //precisa vir uma lista de keys com 2 posicoes  - a regra é clara!\n        console.log(\"Receiving an invalid keys list!\"); //recognizingSomething.push(memorizedQuestion.id)\n      }\n    });\n    const myBrainIsArching = thinkingAboutKeys(analyzeKeys(recognizingSomething)); //analisa as keys identificadas e processa qual delas foi a mais acessada \n    //const keyCompareCache = myBrainIsArching[1]//para futuras atualizacoes\n\n    const hmmIRemember = myBrainIsArching[0]; //envia a resposta ja validada pelo analyzeQuestion\n\n    return getAnswersById(analyzeQuestion(hmmIRemember, userInput));\n  }\n};\nexport default analyzeToAnswer;","map":{"version":3,"sources":["C:/desenv/react-profile/profile/src/components/Chatbot/core/brain.js"],"names":["memory","sameWords","preventStutter","word","padronizeWords","userInput","sameWords_in","sameWords_out","i","length","replace","rememberQuestions","json","result","keys","Object","forEach","key","push","buildStringWithCounter","str","numbers","toString","searchByCounter","prefix","newString","substring","removeCounter","getCounter","parseInt","thinkingAboutKeys","array","memoryCache","moreLikely","unshift","analyzeQuestion","hmmIRemember","partialAnalysis","itemRemembered","obj","id","memorizedQuestion","questions","resultList","splitedMemQuestion","split","splitedInputUser","counterEqualWords","ii","wordInMem","iii","wordInInput","percentualResult","Math","floor","console","log","finalAnalisys","cache","analyzeKeys","recognizingSomething","thingsList","alreadyRecognized","itemRecognized","itemMemorized","prefixCounter","counter","thing","getAnswersById","Array","isArray","eachId","memorizedId","undefined","desc","answers","compareWords","memorizedWord","includes","analyzeToAnswer","compare","passedCounter","twoFactory_1","twoFactory_2","checkKeys","myBrainIsArching"],"mappings":"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","sourcesContent":["import memory from \"./memory.json\";\r\nimport sameWords from \"./sameWords.json\";\r\n\r\n\r\n\r\nfunction preventStutter(word) { //pra evitar que os proximos resultados nao saim embaralhados\r\n    return \" \" + word + \" \"\r\n}\r\n\r\nfunction padronizeWords(userInput) {     // girias ou variacoes \r\n    let sameWords_in = sameWords[0]\r\n    let sameWords_out = sameWords[1]\r\n\r\n    for (let i = 0; i < sameWords_in.length; i++) {\r\n        userInput = preventStutter(userInput).replace(preventStutter(sameWords_in[i]), preventStutter(sameWords_out[i]))\r\n    } //converte palavras com significados iguais aos memorizados\r\n\r\n    return userInput //entrega com as palavras com significados iguais convertidas para palavra padrao\r\n}\r\n\r\n\r\n\r\nfunction rememberQuestions(json) { //retorna perguntas memorizadas\r\n    let result = [];\r\n    let keys = Object.keys(json);\r\n    keys.forEach(function (key) {\r\n        result.push(json[key]);\r\n    });\r\n\r\n    return result\r\n}\r\n\r\nfunction buildStringWithCounter(str, numbers) { //monta string com counter\r\n    if ((numbers >= 0) || (numbers <= 99)) {\r\n        numbers = \"00\" + numbers\r\n    } else if ((numbers > 9) || (numbers <= 99)) {\r\n        numbers = \"0\" + numbers\r\n    } else if ((numbers > 99) || (numbers <= 999)) {\r\n        numbers = toString(numbers)\r\n    } else {\r\n        numbers = \"ERR\"\r\n    }\r\n    let result = str + numbers\r\n    return result\r\n}\r\n\r\nfunction searchByCounter(str) { //procura se string prossui contador true false\r\n    let prefix = \"%%\"\r\n    let newString = str.substring(str.length - 5, str.length - 3)\r\n    let result = false\r\n    if (newString === prefix) {\r\n        result = true\r\n    }\r\n    return result\r\n}\r\n\r\nfunction removeCounter(str) { //remove contador da string para comparações - add validacao\r\n    return str.substring(0, str.length - 5)\r\n}\r\n\r\nfunction getCounter(str) { //add validacao\r\n    return parseInt(str.substring(str.length - 3, str.length))\r\n}\r\n\r\nfunction thinkingAboutKeys(array) { // filtra chaves reconhecidas pelo maior contador informado pela AnalyzeKeys (independente de quantas keys forem)\r\n    let memoryCache // para futuras implementacoes tb \r\n    let moreLikely\r\n\r\n    if(array.length===0){\r\n        moreLikely = [\"%%dontknow%%\"]\r\n    } else {\r\n        for (let i = 0; i < array.length; i++) { //filtra os contadores\r\n            if (memoryCache) {\r\n                if (getCounter(array[i]) >= getCounter(memoryCache[0])) {\r\n                    memoryCache.unshift(array[i])\r\n                } else {\r\n                    memoryCache.push(array[i])\r\n                }\r\n            } else {\r\n                memoryCache = []\r\n                memoryCache.unshift(array[i])\r\n            }\r\n        } //para proximas ideias no reconhecimento\r\n        //console.log(memoryCache)\r\n    \r\n        moreLikely = [memoryCache[0]] // filtra cache com o maior(ou maiores iguais) contador(res)  -- add validacao\r\n        for (let i = 1; i < memoryCache.length; i++) {\r\n            if (getCounter(memoryCache[i]) === getCounter(moreLikely[0])) {\r\n                moreLikely.push(removeCounter(memoryCache[i]))\r\n            }\r\n        }\r\n        moreLikely[0] = removeCounter(moreLikely[0])\r\n    }\r\n    return [moreLikely, memoryCache]\r\n}\r\n\r\nfunction analyzeQuestion(hmmIRemember, userInput) { //dividido em parcial e final/ compara as palavras do input com as questoes memorizadas\r\n    let partialAnalysis = [] //analise parcial\r\n    if(hmmIRemember[0]===\"%%dontknow%%\"){ // converte o nao reconhecido em nao lembrado rs\r\n        partialAnalysis.push(hmmIRemember)\r\n    }\r\n    hmmIRemember.forEach(itemRemembered => { //verifica tudo q ele lembrou ao ler o que o usuario perguntou\r\n        rememberQuestions(memory).forEach(obj => { //carrega cada objetos do json\r\n            if (obj.id === itemRemembered) { //compara cada palavra do input com da pergunta gravada na memoria\r\n                let memorizedQuestion = obj.questions\r\n                let resultList = []\r\n                for (let i = 0; i < memorizedQuestion.length; i++) { //divide frases em palavras\r\n                    let splitedMemQuestion = memorizedQuestion[i].split(\" \")\r\n                    let splitedInputUser = userInput.split(\" \")\r\n                    let counterEqualWords = 0\r\n\r\n                    for (let ii = 0; ii < splitedMemQuestion.length; ii++) { //compara as palavras\r\n                        const wordInMem = splitedMemQuestion[ii]\r\n                        for (let iii = 0; iii < splitedInputUser.length; iii++) {\r\n                            const wordInInput = splitedInputUser[iii]\r\n                            if (wordInInput === wordInMem) {\r\n                                counterEqualWords++ // contadoooor\r\n                            }\r\n                        }\r\n                    }\r\n                    let percentualResult = Math.floor(counterEqualWords / splitedMemQuestion.length * 100)\r\n                    resultList.push(percentualResult)\r\n                }\r\n                let result = resultList[0] //add validacao\r\n                for (let ii = 0; ii < resultList.length; ii++) { //filtra o maior contador\r\n                    if (resultList[ii] > result) {\r\n                        result = resultList[ii]\r\n                    }\r\n                }\r\n                partialAnalysis.push([obj.id, result])\r\n            }\r\n        })\r\n    })\r\n    console.log(partialAnalysis)\r\n    let finalAnalisys // analise final\r\n    let cache = []\r\n\r\n    if (partialAnalysis.length > 1) { //confere se apos analisar a questao se ainda existe um empate\r\n        //finalAnalisys.push(\"%%draw%%\") //seta aqui o prefixo para responder empate\r\n\r\n        for (let i = 0; i < partialAnalysis.length; i++) {\r\n            if(i===0){\r\n                cache.push[partialAnalysis[i]]\r\n            } else {\r\n                if (partialAnalysis[i][1] > cache[0][1]) {\r\n                    finalAnalisys = partialAnalysis[i][0]\r\n                } else if (partialAnalysis[i][1] === cache[0][1]) {\r\n                    finalAnalisys.push\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    } else {\r\n        finalAnalisys = partialAnalysis[0][0]\r\n    }\r\n\r\n    return finalAnalisys\r\n}\r\n\r\nfunction analyzeKeys(recognizingSomething) { //analisa lista de keys reconhecidas - para futuras implementações\r\n    let thingsList = []\r\n    let alreadyRecognized = false\r\n\r\n    for (let i = 0; i < recognizingSomething.length; i++) {//separa os itens reconhecidos\r\n        const itemRecognized = recognizingSomething[i]\r\n\r\n        for (let ii = 0; ii < thingsList.length; ii++) { //separa os itens memorizados\r\n            const itemMemorized = thingsList[ii]\r\n\r\n            if (itemMemorized === itemRecognized) { //compara\r\n                alreadyRecognized = true\r\n            } else {\r\n\r\n                if (searchByCounter(itemMemorized)) {\r\n\r\n                    if (removeCounter(itemMemorized) === itemRecognized) {\r\n                        alreadyRecognized = true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let prefixCounter = \"%%\"\r\n        let counter = 0\r\n        if (alreadyRecognized) {\r\n            for (let ii = 0; ii < thingsList.length; ii++) {\r\n                let thing = thingsList[ii]\r\n\r\n                if (removeCounter(thing) === itemRecognized) {\r\n                    counter++\r\n                    let numbers = parseInt(thing.substring(thing.length - 3, thing.length)) + 1\r\n                    thingsList[ii] = buildStringWithCounter(thingsList[ii].substring(0, thing.length - 3), numbers)\r\n\r\n                } else if (thing === itemRecognized) {\r\n                    thingsList[ii] = buildStringWithCounter(thingsList[ii] + prefixCounter, counter)\r\n\r\n                }\r\n            }\r\n        } else {\r\n            counter++\r\n            thingsList.push(buildStringWithCounter(itemRecognized + prefixCounter, counter))\r\n        }\r\n    }\r\n\r\n    return thingsList\r\n}\r\n\r\nfunction getAnswersById(id) { // retorna respostas do json pelo id da pergunta\r\n    let result = []\r\n\r\n    if (Array.isArray(id)) { // em caso de empate ele recebe mais de 1 lista, entao ele processa a resposta para empate aqui\r\n        for (let i = 0; i < id.length; i++) {\r\n            const eachId = id[i]\r\n            for (let ii = 0; ii < memory.length; ii++) {\r\n                const memorizedId = memory[ii].id\r\n                if (result[0] === undefined) {\r\n                    result.push(\"Eu não entendi muito bem a sua pergunta\")\r\n                    result.push(\"Você quis dizer alguns dos temas abaixo?\")\r\n                } else if ((result[0] !== undefined) && (memorizedId === eachId)) {\r\n                    result.push(memory[ii].desc)\r\n                }\r\n                if (ii === memory) {\r\n                    result.push(\"Caso seja algum desses, me diga qual\")\r\n                    result.push(\"Se não for, tente refazer a pergunta usando outras palavras\")\r\n                }\r\n            }\r\n        }\r\n    } else if (id === \"%%dontknow%%\") { // se nao reconhecer nenhuma chave, nada!\r\n        result.push(\"Essa pergunta eu não conheço =(\")\r\n        result.push(\"Vou anotar e pedir pro Vinícius original me ensinar a responder\")\r\n\r\n    } else { //se souber e for somente 1 item,  caso limpo\r\n        for (let i = 0; i < memory.length; i++) {\r\n            const memorizedId = memory[i].id\r\n            if (memorizedId === id) {\r\n                result = memory[i].answers\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return result\r\n}\r\n\r\nfunction compareWords(userInput, memorizedWord) { //compara palavras - so strings por enquanto\r\n    let result = false\r\n    if (userInput.includes(memorizedWord)) {\r\n        result = true\r\n    }\r\n    return result\r\n}\r\n\r\nconst analyzeToAnswer = {\r\n    compare: (userInput) => {\r\n        let recognizingSomething = []\r\n        userInput = padronizeWords(userInput) // aplica padrao para palavras com msm significado\r\n\r\n        rememberQuestions(memory).forEach(memorizedQuestion => { //verifica se cada key existe no userInput\r\n            let keys = memorizedQuestion.keys\r\n            let passedCounter = 0\r\n            let twoFactory_1 = false //validar as 2 keys\r\n            let twoFactory_2 = false\r\n\r\n            if (typeof (keys) === \"object\") { // precisa receber uma lista - é regra\r\n                for (let i = 0; i < keys.length; i++) { //compara palavras vindas do usuarios com as keys\r\n                    if (typeof (keys[i]) === \"object\") {\r\n                        let checkKeys = keys[i]\r\n                        for (let ii = 0; ii < checkKeys.length; ii++) {\r\n                            if ((passedCounter === 0) && (compareWords(userInput, checkKeys[ii]))) {\r\n                                twoFactory_2 = true\r\n                            } else if ((passedCounter === 1) && (compareWords(userInput, checkKeys[ii]))) {\r\n                                twoFactory_1 = true\r\n                            } else if (passedCounter > 1) {\r\n                                console.log(\"hey, estão me enviando chave a mais para analisar!! so pode 2 mininuuu\")\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if ((passedCounter === 0) && (compareWords(userInput, keys[i]))) {\r\n                            twoFactory_2 = true\r\n                        } else if ((passedCounter === 1) && (compareWords(userInput, keys[i]))) {\r\n                            twoFactory_1 = true\r\n                        } else if (passedCounter > 1) { //precisa vir uma lista de keys com 2 posicoes - a regra é clara!\r\n                            console.log(\"Receiving an invalid keys list!\")\r\n                        }\r\n                    }\r\n                    if ((twoFactory_1) && (twoFactory_2)) {\r\n                        recognizingSomething.push(memorizedQuestion.id)\r\n                    }\r\n                    passedCounter++\r\n                }\r\n            } else {//precisa vir uma lista de keys com 2 posicoes  - a regra é clara!\r\n                console.log(\"Receiving an invalid keys list!\")\r\n                //recognizingSomething.push(memorizedQuestion.id)\r\n            }\r\n        })\r\n        const myBrainIsArching = thinkingAboutKeys(analyzeKeys(recognizingSomething))//analisa as keys identificadas e processa qual delas foi a mais acessada \r\n        //const keyCompareCache = myBrainIsArching[1]//para futuras atualizacoes\r\n        const hmmIRemember = myBrainIsArching[0]\r\n\r\n        //envia a resposta ja validada pelo analyzeQuestion\r\n        return getAnswersById(analyzeQuestion(hmmIRemember, userInput))\r\n    }\r\n\r\n}\r\n\r\nexport default analyzeToAnswer;"]},"metadata":{},"sourceType":"module"}